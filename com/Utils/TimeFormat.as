package com.Utils{	import flash.utils.Timer;	import flash.events.TimerEvent;	/*****************************************************************	* 	Time format class by Ethan S. Lin, October 07, 2011          *	*	Visit www.ethanslin.com for Ethan's portfolio.               *	* 	You may not distribute this code freely without permission.  *	*****************************************************************/	public class TimeFormat	{						/**********************************************		* RETURN INPUTED TIME INTO HH:MM:SS FORMAT    *		* with optional agrument of extending the     *		* time output as HOUR(S) MINUTE(S) SECONDS(S) *		**********************************************/		public static function toHMS(from:String,time:Number,extend:Boolean=false):String		{			if (validateNumInput(time) == false) {				return "00:00";			} else {				return formatToHMS(from,time,extend);			}		}						/**********************************************************		* RETURN TIME IN HH:MM:SS FORMAT TO USER SPECIFIED FORMAT *		**********************************************************/				public static function fromHMS(to:String,timeInHMS:String):Number {			if (validateStringInput(to) == true) {				return formatFromHMS(to,timeInHMS);			} else {				return 0;			}		}								/**************************************************************************		* RETURN USER SPECIFIED TIME FORMAT TO ANOTHER USER SPECIFIED TIME FORMAT *		**************************************************************************/				private static function into(from:String,to:String,time:Number):Number {			return 0; // work in progress		}														/*************************STOP**************************/		/********************************************************		* METHODS TO BE USED FOR THIS CLASS -DO NOT EDIT BELOW- *		********************************************************/		/*************************STOP**************************/				private static function validateNumInput(num:Number):Boolean {			if (num <= 0 || isNaN(num)) {				return false;			} else {				return true;			}		}				private static function validateStringInput(from:String):Boolean {			if (from == "milliseconds" || from == "ms" || from == "millisecond") {				return true;			} else if (from == "seconds" || from == "s" || from == "second") {				return true;			} else if (from == "minutes" || from == "m" || from == "minute" ) {				return true;			} else if (from == "hours" || from == "h" || from == "hour") {				return true;			} else {				return false;			}		}		private static function formatToHMS(from:String,time:Number,extend:Boolean):String {									if (validateStringInput(from) == false) {				return "TIME FORMAT ERROR: invalid string value. Accepted string values: milliseconds, millisecond, ms, seconds, second, s, minutes, minute, m, hours, hour, and h.";			} else {				return getFirstMS(from,time,extend);			}					}						private static function getFirstMS(from:String,time:Number,extend:Boolean):String {			var hours:Number;			var remainder:Number;			var minutes:Number;			var seconds:Number;			var hString:String;			var mString:String;			var sString:String;						if (from == "milliseconds" || from == "ms" || from == "millisecond") {				hours = time / (60 * 60 * 1000);			} else if (from == "seconds" || from == "s" || from == "second") {				hours = time / (60 * 60);			} else if (from == "minutes" || from == "m" || from == "minute" ) {				hours = time / 60;			} else if (from == "hours" || from == "h" || from == "hour") {				hours = time;			}						remainder = hours - (Math.floor(hours));			hours = Math.floor(hours);			minutes = remainder * 60;			remainder = minutes - (Math.floor(minutes));			minutes = Math.floor(minutes);						if (minutes >= 60) {				hours += 1;				minutes = 0;			}			seconds = remainder * 60;			remainder = seconds - (Math.floor(seconds));			seconds = Math.round(seconds);						if (seconds >= 60) {				minutes += 1;				seconds = 0;			}			hString = hours < 10 ? "0" + hours:"" + hours;			mString = minutes < 10 ? "0" + minutes:"" + minutes;			sString = seconds < 10 ? "0" + seconds:"" + seconds;					if (extend == false) {				if (hours > 0) {					return hString + ":" + mString + ":" + sString;				} else {					return mString + ":" + sString;				}			} else {				return getExtended(hours,minutes,seconds,hString,mString,sString);			}		}				private static function getExtended(h:Number,m:Number,s:Number,hS:String,mS:String,sS:String):String {			var nHour:String;			var nMin:String;			var nSec:String;											nHour = h > 1 ? " HOURS ":" HOUR ";			nMin = m > 1 ? " MINUTES ":" MINUTE ";			nSec = s > 1 ? " SECONDS ":" SECOND ";						if (h > 0) {				if (m <= 0 && s > 0) {					return hS + nHour + sS + nSec;				} else if (s <= 0 && m > 0) {					return hS + nHour + mS + nMin;				} else if (m <= 0 && s <= 0) {					return hS + nHour;				} else {					return hS + nHour + mS + nMin + sS + nSec;				}			} else if (h <= 0 && m <= 0) {				return sS + nSec;			} else if (h <= 0 && s <= 0) {				return mS + nMin;			} else if (m <= 0 && s <= 0) {				return hS + nHour;			} else {				return mS + nMin + sS + nSec;			}		}				private static function formatFromHMS(to:String,timeInHMS:String):Number {			if (validateHMS(timeInHMS) == true) {				return timeFromHMS(to,timeInHMS);			} else {				return 0;			}		}				private static function validateHMS(HMS:String):Boolean {			if (contains(HMS) == true && (HMS.length >= 5 && HMS.length <= 8)) {				return true;			} else if (contains(HMS) == true && HMS.length == 5) {				return true;			} else {				return false;			}		}				private static function timeFromHMS(to:String,timeInHMS:String):Number {			var hour:Number;			var minute:Number;			var second:Number;			var timeResult:Number;			var secString:String;			var minString:String;			var hrString:String;			var remainder:Number;						if (timeInHMS.length > 5 && timeInHMS.length < 8) {				hour = 0;				minString = getFirst(timeInHMS);				minute = Number(minString);				if (minute >= 60) {					while (minute >= 60) {						remainder = minute - 60;						minute = remainder;						hour++;					}					minute = remainder;				} else if (minute <= 0) {					minute = 0;				} else {					minute = minute;				}			} else {				hrString = getFirst(timeInHMS);				hour = Number(hrString);				minString = getMiddle(timeInHMS);				minute = Number(minString);				if (minute >= 60) {					minute = 60;				} else if (minute <= 0) {					minute = 0;				} else {					minute = minute;				}			}						secString = getLast(timeInHMS);			second = Number(secString);			if (second >= 60) {				second = 60;			} else if (second <= 0) {				second = 0;			} else {				second = second;			}						if (to == "ms" || to == "milliseconds" || to == "millisecond") {				hour = hour * 3600000;				minute = minute * 60000;				second = second * 1000;				timeResult = hour + minute + second;			} else if (to == "s" || to == "seconds" || to == "second"){				hour = hour * 3600;				minute = minute * 60;				second = second * 1;				timeResult = hour + minute + second;			} else if (to == "m" || to == "minutes" || to == "minute"){				hour = hour * 60;				minute = minute * 1;				second = second * (1 / 60);				timeResult = hour + minute + second;			} else if (to == "h" || to == "hours" || to == "hour"){				hour = hour * 1;				minute = minute * (1 / 60);				second = second * (1 / 3600);				timeResult = hour + minute + second;			} else {				timeResult = 0;			}						return timeResult;					}				private static function contains(HMS:String):Boolean {			if (HMS == null) {				return false;			}			return HMS.indexOf(":") != -1;		}								private static function getFirst(H:String):String {			var index:int;						if (H == null) {				return '';			}						index = H.indexOf(":");        	if (index == -1) {				return '';			}			        	return H.substr(0, index);		}				private static function getMiddle(M:String):String {			var str:String = '';			var startIndex:int;			var endIndex:int;			var indicator:String = ":";						if (M == null) {				return str;			}						startIndex = M.indexOf(indicator);						if (startIndex != -1) {				startIndex += indicator.length;				endIndex = M.indexOf(indicator, startIndex);				if (endIndex != -1) {					str = M.substr(startIndex, endIndex-startIndex);				}			}						return str;		}				private static function getLast(S:String):String {			var index:int;			var indicator:String = ":";						if (S == null) {				return '';			}						index = S.lastIndexOf(indicator);						if (index == -1) {				return '';			}						index += indicator.length;						return S.substr(index);		}			}}